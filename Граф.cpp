/********************************************************************************
 * Л А Б О Р А Т О Р Н А Я   Р А Б О Т А  № 2  З А   3   С Е М Е С Т Р   С  +  +*
 *------------------------------------------------------------------------------*
 * Project Type  : Win64 Console Application                                    *
 * Project Name  : Graph                                                        *
 * File Name     : Граф. CPP                                                    *
 * Programmer(s) : Викулов Д.Г.                                                 *
 * Modifyed By   :                                                              *
 * Created       : 05/12/22                                                     *
 * Last Revision : 09/12/22                                                     *
 * Comment(s)    : Программа реализует алгоритмы Дейкстры и Крускала через      *
 *				   матрицу смежности, причём в поиске кратчайших путей выводятся*
 *                 предшествующие вершины                                       *
 ********************************************************************************/

#include <iostream>    // стандартные потоки ввода/вывода
#include <set>         // класс контейнера стандартной библиотеки
#include <fstream>     // файловые потоки ввода/вывода
#include <iomanip>     // библиотека с модификатором setw
using namespace std;   // используем пространство имён std


/*******************************************************************/
/*                    Н А Б О Р    Т Е С Т О В                     */
/*******************************************************************/
//const char* FNAME = "Matr_smeg.txt";
const char* FNAME = "Matr_4x4.txt";


/*******************************************************************/
/*            Г Л О Б А Л Ь Н Ы Е   П Е Р Е М Е Н Н Ы Е            */
/*******************************************************************/
struct Node            // реализация вершины графа с ребром перехода  
{
	int versh;         // номер вершины
	int weight;        // вес ребра, по которому можно перейти в вершину
	Node* next;        // указатель на следующий элемент, в который можно перейти из вершины    
};


/***************************************************************/
/*          П Р О Т О Т И П Ы    Ф У Н К Ц И Й                 */
/***************************************************************/
// считывание и создание динамической матрицы из файла
int reading_matr(int*** ppMatr       // указатель на указатель на массив указателей строк матрицы
	           , int* rN             // реальное количество строк
	           , int* rM             // реальное количество столбцов
	           , const char* FNAME); // имя файла

// печать матрицы
void printMatr(int** ppMatr          // указатель на первый элемент массива указателей
	         , int rN);              // реальное количество строк и столбцов матрицы

// освободить память матрицы
void ReleaseMatr(int** ppMatr        // указатель на массив указателей
	           , int rN);            // реальное количество строк

// алгоритм Дейкстры для матрицы смежности
void Dekstra_matr(int** matrix       // указатель на массив указателей
	            , int S              // исходная вершина старта
	            , int N);            // количество вершин в графе

// печать списка смежности на экран
void print_list(Node** ish_versh     // указатель на массив указателей на структуры
	          , int rN);             // количество элементов массива указателей

// алгоритм Дейкстры для списка смежности
void Dekstra_list(Node** ish_versh   // указатель на массив указателей на структуры
	            , int S              // исходная вершина старта
	            , int N);            // количество вершин в графе

// добавление вершины и веса в список
void Adding_to_the_end(Node** head   // указатель на указатель на начало списка, т.к изменяется
	                 , Node** end    // указатель на указатель на конец списка, чтобы при вызове элемент добавлялся всегда в конец
	                 , int weight    // вес ребра перехода в данную вершину
	                 , int i);       // номер вершины

// удаление списка полностью
void Deleting_a_List(Node**ish_versh // указатель на массив указателей на структуры
	               , int rN);        // количество элементов массива указателей

// находим корень множества для v
int findParent(int v                 // элемент множества
	         , int* parent);         // массив предков множества

// алгоритм Крускала через матрицу смежности
void Kruskala_matr(int** matrix      // указатель на массив указателей
	             , int N);           // количество вершин графа

// алгоритм Крускала через списки смежности
void Kruskala_list(Node**ish_versh   // указатель на массив указателей
                 , int N);           // количество вершин графа


/*******************************************************************/
/*               О С Н О В Н А Я     П Р О Г Р А М М А             */
/*******************************************************************/
int main()
{
	system("cls");            // очистка консоли
	system("color F0");       // делаем  консоль белым
	setlocale(LC_ALL, "Rus"); // подключаем русский язык
	int first;                // вершина, от которой ищутся кратчайшие пути    
	int rN;                   // количество строк матрицы
	int rM ;                  // количество столбцов матрицы  
	ifstream fin;             // объявление объекта для потокового введения данных из файла
	fin.open(FNAME);          // связываем обЪект с файлом. Открываем для чтения
	fin >> rN;                // считываем первый элемент файла - количиство вершин графа
	rM = rN;                  // количество строк и столбцов матрицы смежности одинаково - матрица квадратная
	int** ppMatr = NULL;      // указатель на матрицу указателей на строки матрицы смежности
	//создаём динамический массив указателей на списки
	Node** ish_versh = new struct Node*[rN];
	cout << "\t\t\t\t\t\t \x1b[35mР А Б О Т А   С   Г Р А Ф А М И\x1b[30m\n\n";
	// заполнение матрицы из файла
	reading_matr(&ppMatr, &rN, &rM, FNAME);
	cout << "\n\t\t\t\t\t\t   \x1b[33mВыведем матрицу смежности\x1b[30m\n\n";
	printMatr(ppMatr, rN);    // вывод считанной матрицы на экран
	cout << "\nНачальная вершина: ";
	cin >> first;             // вводим вершину, от которой будем считать кратчайшие пути
	cout << "\t\t\t\t\t\x1b[31m    Алгоритм Дейкстры через матрицу смежности \x1b[30m\n\n";
	// алгоритм дейкстры для матрицы смежности
	Dekstra_matr(ppMatr, first, rN);
	cout << "\n\t\t\t\t\t\t\x1b[33mВычисления через списки смежности\x1b[30m\n\n " << endl;
	cout << "\x1b[34mИсходные данные списка:\x1b[30m \n";
	cout << "Количество элементов в массиве указателей: " << rN << endl;
	cout << "Количество элементов в строке списка: " << rM << endl;

	// создание списка смежности из матрицы смежности, записанной в файле
	{
		int CountLine = 0;    // счётчик по строкам матрицы
		int CountColumn = 0;  // счётчик по столбцам матрицы
		int i = 0;            // счётчик по номерам вершин
		int weight;           // вес перехода в очередную вершину
		Node* end = NULL;     // указатель на конец списка смежности под очередную вершину
		Node* head = NULL;    // указатель на начало списка смежности под очередную вершину
		for (i = 0; i < rN; i++)    // выделение памяти под каждый элемент строки конкретной длины  
		{
			ish_versh[i] = NULL;    // обнуляем указатели на списки для каждой вершины
		}//for i
		i = 0;                      // обнуляем счётчик
		while (!fin.eof())          // пока не дошли до конца файла
		{
			fin >> weight;          // считываем значение из файла
			if (weight != 0)        // если есть путь из данной вершины в другие
			{   
				// для данной вершины добавляем путь и вершину, в которую можем перейти из данной в список для рассматриваемой вершины
				// в конец списка вершин возможных переходов для данной вершины
				Adding_to_the_end(&ish_versh[CountLine], &end, weight, CountColumn);
			}//if(weight)
			// движемся по вершинам матрицы межности, если найдем ненулевое ребро, то CountColumn-номер вершины, в которую можем перейти по данному ребру
			CountColumn = CountColumn + 1;
			if (CountColumn == rN)  // если просмотрели пути до всех возможных вершин
			{
				CountColumn = 0;    // перешли к другой вершине - начинаем опять смотреть все вершины для неё сначала
				// перешли к другой вершине - элементу массива указателей
				CountLine = CountLine + 1;
				end = 0;            // списка для этой вершины нет - обнуляем его конец
			}// if(Column)
		}// while 
		fin.close();                // закрыть файл  
	}// список создан
	print_list(ish_versh, rN);      // выводим сформированный список смежности на экран
	cout << "\n\n\t\t\t\t\t\x1b[31m     Алгоритм Дейкстры через списки смежности \x1b[30m\n\n";
	// алгоритм дейкстры для списка
	Dekstra_list(ish_versh, first, rN);
	cout << "\n\n\t\t\t\t\t\x1b[31m     Алгоритм Крускала через матрицу смежности \x1b[30m\n\n";
	Kruskala_matr(ppMatr, rN); // алгоритм крускала через матрицу смежности
	ReleaseMatr(ppMatr, rN);  // удаляем выделенную динамическую память под матрицу
	cout << "\n\n\t\t\t\t\t\x1b[31m     Алгоритм Крускала через списки смежности \x1b[30m\n\n";
	Kruskala_list(ish_versh, rN);       
	// список смежности отработан - удаляем для каждого элемента массива свой список
	Deleting_a_List(ish_versh, rN);
	delete[]ish_versh;              // удаляем сам динамический массив указателей на списки
	system("pause");
	return 0;                       // возвращаем обещанное число
}//end main


 /***************************************************/
 /*             РЕАЛИЗАЦИЯ ФУНКЦИЙ                  */
 /***************************************************/

 /*-------------------------------------------------*/
 /* чтение матрицы из файла */
 /*-------------------------*/
int reading_matr(int*** ppMatr       // указатель на указатель на массив указателей строк матрицы
	           , int* rN             // реальное количество строк
	           , int* rM             // реальное количество столбцов
	           , const char* FNAME)  // имя файла
{
	int CountLine = 0;                // счётчик по строкам
	int CountColumn = 0;              // счётчик по столбцам
	int i = 0;                        // счётчик
	ifstream fin;                     // объявление объекта для потокового введения данных из файла
	fin.open(FNAME);                  // связываем обЪект с файлом. Открываем для чтения
	if (!fin.is_open())               // файл не найден
	{
		cout << "\nОШИБКА!!! Не удалось открыть файл\n\n";
		fin.close();                  // закрыть файл
		system("pause");
		exit(1);                      // заканчиваем программу из функции
	}// if

	if (fin.peek() == EOF)            // файл пуст
	{
		cout << "\nОШИБКА!!! Файл для чтения пуст\n\n";
		fin.close();                  // закрыть файл
		system("pause");
		exit(2);                      // заканчиваем программу из функции
	}// if

	fin >> *rN;                       // считываем количество строк (число *rN, а не указатель rN)
	*rM = *rN;                        // матрица квадратная - часло строк равно числу столбцов
	if (fin.fail())                   // в файле не число (прочитали две первых строки - заметили несоответствие типов)
	{
		cout << "\nОШИБКА!!! Среди элементов файла нечисло\n\n";
		fin.close();                  // закрыть файл
		system("pause");
		exit(3);                      // заканчиваем программу из функции
	}// if
	// вывели считанные данные-количество строк и столбцов из файла
	cout << "Исходные данные матрицы: \n";
	cout << "Количество строк: " << *rN << endl;
	cout << "Количество столбцов: " << *rM << endl;
	if (*rN < 0)                      // число строк отрицательно
	{

		cout << "\nОШИБКА!!! В качестве числа строк/столбцов введено отрицательное число\n\n";
		fin.close();                  // закрыть файл
		system("pause");
		exit(4);                      // заканчиваем программу из функции
	}// if
	*ppMatr = new int* [*rN];         // создаём динамическую матрицу из указателей на строки с учётом того, что мы передавали указатель в функцию. Их rN штук
	for (i = 0; i < *rN; i++)         //выделение памяти под каждый элемент строки конкретной длины  
	{
		(*ppMatr)[i] = new int[*rM];  // на каждую строку матрицы указателей выделяем  динамический массив длиной rM=rN
	}// for i
	i = 0;                            // обнуляем счётчик
	while (!fin.eof())                // пока не дошли до коца файла
	{
		if (i >= (*rN * *rM))         // реальное количество больше объявленного
		{
			//вызов функции с ФАКТИЧЕСКИМИ параметрами
			cout << "\nОШИБКА!!! В матрице указано больше элементов, чем она вмещает\n\n";
			ReleaseMatr(*ppMatr, *rN);             // удаляем выделенную динамическую память
			fin.close();                           // закрыть файл
			system("pause");
			exit(5);                               // заканчиваем программу из функции
		}// if
		fin >> (*ppMatr)[CountLine][CountColumn];  // считали элемент, поместили его на место pmatr[CountLine][CountColumn]. С учётом ПЕРЕДАЧИ УКАЗАТЕЛЯ В ФУНКЦИЮ
		CountColumn = CountColumn + 1;             // перешли к следующему столбцу
		if (CountColumn == *rM)                    // если достигли конца строки
		{
			CountLine = CountLine + 1;             // переходим к другой строке
			CountColumn = 0;                       // становимся на начало строки
		}//if
		if (fin.fail())                            // проверка на нечисло в самом массиве (на соответствие типов данных)
		{
			cout << "\nОШИБКА!!! Среди элементов матрицы содержится элемент, не являющийся числом\n\n";
			ReleaseMatr(*ppMatr, *rN);             // удаляем выделенную динамическую память
			fin.close();                           // закрыть файл
			system("pause");
			exit(6);                               // заканчиваем программу из функции
		}// if
		i = i + 1;                                 // увеличили счётчик
	}// while 
	if (i < (*rN * *rM))                           // реальное количество элементов меньше объявленного
	{
		//вызов функции с ФАКТИЧЕСКИМИ параметрами
		cout << "\nОШИБКА!!! В матрице указано меньше элементов, чем она вмещает\n\n";
		ReleaseMatr(*ppMatr, *rN);                 // удаляем выделенную динамическую память
		fin.close();                               // закрыть файл
		system("pause");
		exit(7);                                   // заканчиваем программу из функции
	}// if
	fin.close();                                   // закрыть файл
	return 0;                                      // возвращаем значение, соответствующее типу, если всё хорошо
}// reading_matr()


 /*-------------------------------------------------*/
 /* печать матрицы */
 /*----------------*/
void printMatr(int** ppMatr          // указатель на первый элемент массива указателей
	         , int rN)               // реальное количество строк и столбцов матрицы
{
	setlocale(0, "C");               // отключаем русский язык
	int i;                           // движение по строкам матрицы
	int j;                           // движение по столбцам матрицы
	// выводим отступ перед выводом номеров столбцов
	cout << endl << setw(6) << setfill(' ');
	// выводим номера столбцов матрицы смежности
	for (i = 0; i < rN; i++)
	{
		cout << i << setw(6) << setfill(' ');
	}// for i
	// вывод верхней границы матрицы
	cout << endl << setw(4) << setfill(' ') << char(218) << setw(i * 6 - 1) << setfill(char(196)) << char(191) << endl;
	// идём по всем строкам матрицы
	for (i = 0; i < rN; i++)
	{
		// выводим номера строк матрицы смежности построчно
		cout << char(' ') << i << char(' ') << char(179) << char(' ');
		// идём по столбцам матрицы смежности до последнего
		for (j = 0; j < rN - 1; j++)
		{
			// выводим элемент матрицы смежности с пробелом между соседом
			cout << ppMatr[i][j] << setw(6) << setfill(' ');
		}// for j
		// выводим последний элемент матрицы смежности и пробел поменьше
		cout << ppMatr[i][j] << setw(3) << setfill(' ');
		// выводим боковую часть рамки
		cout << char(179) << endl << setw(4) << setfill(' ') << char(179) << setw((j + 1) * 6 - 1) << setfill(' ') << char(179) << endl;
	}// for i
	// выводим нижнюю границу матрицы смежности
	cout << setw(4) << setfill(' ') << char(192) << setw(i * 6 - 1) << setfill(char(196)) << char(217) << endl;
	setlocale(LC_ALL, "Rus");        // подключаем русский язык
	return;                          // возвращаем обещанное значение
}// printMatr()


/*-------------------------------------------------------------*/
/* Удаление динамической матрицы  */
/*--------------------------------*/
void ReleaseMatr(int** ppMatr                  // указатель на массив указателей
	           , int rN)                       // реальное количество строк
{
	int i;                                     // счётчик
	//освобождение памяти в обратном порядке
	for (i = 0; i < rN; i++)
	{
		delete[] ppMatr[i];                    // удаляем строки  (массивы)
	}// for i

	delete[] ppMatr;	                       // удаляем массив указателей на строки
	return;                                    // вернули обещанное значение в caller
}// ReleaseMatr()


/*-------------------------------------------------------------*/
/* алгоритм Дейкстры для матрицы смежности  */
/*------------------------------------------*/
void Dekstra_matr(int** matrix       // указатель на массив указателей
	            , int S              // исходная вершина старта
	            , int N)             // количество вершин в графе
{
	int* shortest = new int[N];      // массив кратчайших путей до всех вершин от данной, поэтому размер массива не выйдет за пределы N
	int i;                           // для цикла
	int j;                           // для цикла
	int* pred = new int[N];          // массив предыдущих вершин для каждой в алгоритме
	int min;                         // для поиска минимального пути
	int U;                           // очередная рассматриваемая вершина с минимальным весом
	int V;                           // вершина, для которой существует путь U->V
	set <int> q;                     // множество вершин графа
	for (j = 0; j < N; j++)          // идём по всем элемента массива кратчайших путей
	{
		if (j == S)                  // если наткнулись на индекс, равный индексу вершины, от которой будем искать кратчайшие пути
		{
			shortest[j] = 0;         // помещаем на это место 0
		}
		else
		{
			shortest[j] = INT_MAX;   // все остальные пути - бесконечные
			pred[j] = 0;             // а предыдущих вершин пока нет ни у кого
		}// if
		q.insert(j);                 // добавляем все вершины графа в множество вершин
	}// for j

	// пока не рассмотрели все вершины множества
	while (!q.empty())
	{
		U = *q.begin();              // берем первый элемент множества за элемент с минимальным весом
		min = shortest[*q.begin()];  // принимаем вес первого элемента за минимальный
		for (i = 1; i < N; i++)      // идём по всем элементам массива кратчайших путей
		{
			// если какой-то вес меньше, чем вес первого элемента и данная вершина ещё не рассмотрена
			if ((min > shortest[i]) && (q.find(i) != q.cend()))
			{
				min = shortest[i];   // эта вершина будет вершиной с минимальным весом
				U = i;               // запоминаем её номер
			}// if
		}// for i
		// если рассмотрели все элементы с минимальными весами. Остались только вершины, к которым нельзя пройти
		if (min == INT_MAX)
		{
			break;                   // заканчиваем цикл
		}// if
		q.erase(U);                  // удаляем вершину с минимальным весом из множества - она отработана
		// движемся по всем элементам строки данной вершины
		for (i = 0; i < N; i++)
		{
			if (matrix[U][i] != 0)   // если от данной вершины есть путь к другой вершине
			{
				V = i;               // запоминаем номер вершины, к которой есть путь
				// если вес рассматриваемой вершины в сумме с весом до той вершины, к которой существует путь меньше, чем уже записанный вес этой вершины
				if ((shortest[U] + matrix[U][V]) < shortest[V])
				{
					// ставим новый вес вершины, к которой есть путь из данной
					shortest[V] = shortest[U] + matrix[U][V];
					// запоминаем данную вершину как предыдущую для V
					pred[V] = U;
				}// if
			}// if
		}// for
	}// while
	// идём по все элементам массивов shortest и pred
	for (i = 0; i < N; i++)
	{
		cout << "Длина кратчайшего пути от " << S << " до " << i << " равна: ";
		// если путь не бесконечность - существует
		if (shortest[i] != INT_MAX)
		{
			cout << shortest[i];     // выводим его
		}
		// пути в данную вершину не существует
		else                        
		{  
			// уведомляем об этом
			cout << "маршрут недоступен";
		}// if

		// если путь не бесконечность-существует и вершина-не исходная
		if (shortest[i] != INT_MAX && shortest[i]!=0)
		{
			// выводим предыдущую для нее в алгоритме
			cout << ", предшествующая вершина : " << pred[i] << ";\n";
		}
		else
		{
			// если вершина исходная или пути нет - уведомляем об этом
			cout << ", предшествующей вершины нет" << ";\n";
		}//if
	}//for i
	delete[] shortest;                // удаляем отработанные динамичесике массивы
	delete[] pred;
	return;                           // возвращаем обещанное значение
}// Dekstra_matr()


/*-------------------------------------------------------------*/
/* печать списка смежности на экран  */
/*-----------------------------------*/
void print_list(Node** ish_versh     // указатель на массив указателей на структуры
	          , int rN)              // количество элементов массива указателей
{
	Node* ptr;                       // указатель на очередной узел списка
	setlocale(0, "C");               // отключаем русский язык
	// выводим верхнюю строку матрицы указателей
	cout << char(218) << setw(5) << setfill(char(196)) << char(191) << setw(8) << setfill(' ');
	// едём по всем элементам матрицы указателей
	for (int i = 0; i < rN; i++)
	{
		ptr = ish_versh[i];          // рассматриваем списки построчно
		while (ptr != NULL)          // проходим по списку
		{
			// выводим шапки каждого элемента списка
			cout << char(218) << setw(6) << setfill(char(196)) << char(194) << setw(6) << setfill(char(196)) << char(194) << setw(6) << setfill(char(196)) << char(191) << char(' ');
			ptr = ptr->next;         // переходим к следующему элементу списка
		}//while
		// перешли к следующей строке - выводим боковые границы массива и сам элемент массива указателей
		cout << endl << char(179) << setw(2) << setfill(' ') << i << setw(3) << setfill(' ') << char(195);
		// опять рассматриваем список заново
		ptr = ish_versh[i];
		// выводим стрелку между массивом и головой списка
		cout << setw(7) << setfill(char(196)) << char(62);
		// проходим по всему списку
		while (ptr != NULL)
		{
			// выводим боковую границу элемента
			cout << char(180);
			cout << setw(3) << setfill(' ');
			// выводим значение вершины, в которую можно попасть из данной
			cout << ptr->versh;
			cout << setw(3) << setfill(' ') << char(179) << setw(3) << setfill(' ');
			// выводим вес ребра, по которому можем попасть в эту впершину из данной
			cout << ptr->weight;
			cout << setw(3) << setfill(' ') << char(179) << setw(3) << setfill(' ');
			// выводим обозначение, что есть следующий элемент списка
			cout << "*";
			cout << setw(3) << setfill(' ') << char(195);
			// переходим к следующему элементу
			ptr = ptr->next;
			// выводим боковую границу элемента списка
			cout << char(196);
		}//while
		// для последнего элемента списка выводим то, что он указывает на ноль - за ним нет больше элементов
		cout << char(196) << char(196) << char(62) << " NULL" << endl;
		//выводим боковые границы матрицы указателей
		cout << char(179) << setw(5) << setfill(' ') << char(179);
		// опять отступаем от неё для работы с элементами списка
		cout << setw(8) << setfill(' ');
		// начинаем проходить список для того же элемента массива сначала
		ptr = ish_versh[i];
		while (ptr != NULL)
		{
			// выводим нижнюю шапку каждого элемента списка
			cout << char(192) << setw(6) << setfill(char(196)) << char(193) << setw(6) << setfill(char(196)) << char(193) << setw(6) << setfill(char(196)) << char(217);
			// переходим к следующему элементу
			ptr = ptr->next;
			cout << char(' ');
		}//while
		// до последнего элемента массива
		if (i < rN - 1)
		{
			// выводим пересечение боковых границ между элементами массива
			cout << endl << char(195) << setw(5) << setfill(char(196)) << char(180) << setw(8) << setfill(' ');
		}
		// для последнего элемента массива
		else
		{
			// выводим нижнюю границу без продолжения
			cout << endl << char(192) << setw(5) << setfill(char(196)) << char(217) << setw(8) << setfill(' ');
		}// if i
		//cout << endl;
	}//for i
	setlocale(LC_ALL, "Rus");       // подключаем русский язык
	return;                         // вернули обещанное значение в caller
}// print_list()


/*-------------------------------------------------------------*/
/* алгоритм Дейкстры для списка смежности  */
/*-----------------------------------------*/
void Dekstra_list(Node** ish_versh   // указатель на массив указателей на структуры
	            , int S              // исходная вершина старта
	            , int N)             // количество вершин в графе
{
	int* shortest = new int[N];      // массив кратчайших путей до всех вершин от данной, поэтому размер массива не выйдет за пределы N        
	int i;                           // для цикла
	int j;                           // для цикла
	int* pred = new int[N];          // массив предыдущих вершин для каждой в алгоритме
	int min;                         // для поиска минимального пути
	int U;                           // очередная рассматриваемая вершина с минимальным весом
	int V;                           // вершина, для которой существует путь U->V
	Node* ptr;                       // указатель на очередной элемент списка
	set <int> q;                     // множество вершин графа
	for (j = 0; j < N; j++)          // идём по всем элемента массива кратчайших путей
	{
		if (j == S)                  // если наткнулись на индекс, равный индексу вершины, от которой будем искать кратчайшие пути
		{
			shortest[j] = 0;         // помещаем на это место 0
		}
		else
		{
			shortest[j] = INT_MAX;   // все остальные пути - бесконечные
			pred[j] = 0;             // а предыдущих вершин пока нет ни у кого
		}// if
		q.insert(j);                 // добавляем все вершины графа в множество вершин
	}// for j

	// пока не рассмотрели все вершины множества
	while (!q.empty())
	{
		U = *q.begin();              // берем первый элемент множества за элемент с минимальным весом
		min = shortest[*q.begin()];  // принимаем вес первого элемента за минимальный
		for (i = 1; i < N; i++)      // идём по всем элементам массива кратчайших путей
		{
			// если какой-то вес меньше, чем вес первого элемента и данная вершина ещё не рассмотрена
			if ((min > shortest[i]) && (q.find(i) != q.cend()))
			{
				min = shortest[i];   // эта вершина будет вершиной с минимальным весом
				U = i;               // запоминаем её номер
			}// if
		}// for i
		// если рассмотрели все элементы с минимальными весами. Остались только вершины, к которым нельзя 
		if (min == INT_MAX)
		{
			break;                   // заканчиваем цикл
		}// if
		q.erase(U);                  // удаляем вершину с минимальным весом из множества - она отработана
		ptr = ish_versh[U];          // берем список для вершины U, записанной в массив смежности
		while (ptr != NULL)
		{		
			// для элементов списка путь всегда есть. При добавлении были учтены ненулевые веса
			// запоминаем вершину, к которой есть путь
			V = ptr->versh;
			// если вес рассматриваемой вершины в сумме с весом до той вершины, к которой существует путь меньше, чем уже записанный вес этой вершины
			if ((shortest[U] + ptr->weight) < shortest[V])
			{
				// ставим новый вес вершины, к которой есть путь из данной
				shortest[V] = shortest[U] + ptr->weight;
				// запоминаем данную вершину как предыдущую для V
				pred[V] = U;
			}// if
		// рассматриваем следующий элемент списка-вершину, к которой есть путь
		ptr = ptr->next;
		}// while
	}// while
	// идём по все элементам массивов shortest и pred
	for (i = 0; i < N; i++)
	{
		cout << "Длина кратчайшего пути от " << S << " до " << i << " равна: ";
		// если путь не бесконечность - существует
		if (shortest[i] != INT_MAX)
		{
			cout << shortest[i];     // выводим его
		}
		// пути в данную вершину не существует
		else
		{
			// уведомляем об этом
			cout << "маршрут недоступен";
		}// if

		// если путь не бесконечность-существует и вершина-не исходная
		if (shortest[i] != INT_MAX && shortest[i] != 0)
		{
			// выводим предыдущую для нее в алгоритме
			cout << ", предшествующая вершина : " << pred[i] << ";\n";
		}
		else
		{
			// если вершина исходная или пути нет - уведомляем об этом
			cout << ", предшествующей вершины нет" << ";\n";
		}//if
	}//for i
	delete[] shortest;               // удаляем отработанные динамичесике массивы
	delete[] pred;
	return;                          // возвращаем обещанное значение
}// Dekstra_list()


/*-------------------------------------------------------------*/
/* добавление вершины и веса в список  */
/*-------------------------------------*/
void Adding_to_the_end(Node** head   // указатель на указатель на начало списка, т.к изменяется
	                 , Node** end    // указатель на указатель на конец списка, чтобы при вызове элемент добавлялся всегда в конец
	                 , int weight    // вес ребра перехода в данную вершину
	                 , int i)        // номер вершины
{
	Node* ptr;                       // указатель на очередной узел списка
	ptr = new Node;                  // создали новый узел
	if (*head == NULL)               // если ещё нет ни одного элемента в списке
	{
		*head = ptr;                 // добавленный элемент будет началом
		(*head)->next = *end;        // следующего элемента - нет
	}
	//иначе-начало в списке уже есть
	else
	{
		(*end)->next = ptr;          // добавляем элемент за концом списка, сформированного ранее
	}// if (*head == NULL)
	ptr->versh = i;                  // помещаем туда номер вершины
	ptr->weight = weight;            // помещаем вес вершины, если отталкиваться от данной
	*end = ptr;                      // сместили конец списка на добавленный элемент
	(*end)->next = NULL;             // соответсятвенно за новым концом больше нет элементов списка - элемент добавлен
	return;                          // добавили - вернулись в caller
}// Adding_to_the_end()


/*-------------------------------------------------------------*/
/* удаление списка полностью */
/*---------------------------*/
void Deleting_a_List(Node** ish_versh // указатель на массив указателей на структуры
	               , int rN)          // указатель на указатель на начало списка, т.к изменяется
{
	// узаление происходит движение по списку с первого элемента до последнего
	Node* ptr;                        // указатель на очередной узел списка
	Node* head;                       // указатель на начало очередного списка при движении по массиву
	int i;                            // счётчик для движения по массиву
	// движемся по массиву - удаляем списки
	for (i = 0; i < rN; i++)
	{
		head = ish_versh[i];          // массив указателей -> сам элемент массива-указатель на первый элемент списка(голова списка)
		ptr = NULL;                   // инициализировали ptr, чтобы не был диким
		while (head != NULL)          // пока не вышли за пределы списка
		{
			ptr = (head)->next;       // запоминаем следующий за первым узел списка
			delete head;              // удалили первый узел
			head = ptr;               // переместили начало на запомненный узел
			// теперь удаляем его
		}//while (*head != NULL)
	}// for i
	return;                           // удалили список - вернулись в caller
}// Deleting_a_List()


/*-------------------------------------------------------------*/
/* находим корень множества для v */
/*--------------------------------*/
int findParent(int v                 // элемент множества
	         , int* parent)          // массив предков множества
{
	if (parent[v] == v)  // если потомок - сам корень
	{
		return v;        // возвращаем его
	}// if

	// повторяем для родителя, пока не найдём корень
	return findParent(parent[v], parent);
}// findParent()


/*-------------------------------------------------------------*/
/* алгоритм Крускала через матрицу смежности  */
/*--------------------------------------------*/
void Kruskala_matr(int** matrix  // указатель на массив указателей
	              ,int N)        // кол-во элементов в матрице (вершин)
{
	int number = 0;              // переменная для количества пройденных рёбер
	int weight = 0;              // вес минимального остовного дерева
	int* parent = new int[N];    // выделение памяти под массив для поиска родителей

	for (int i = 0; i < N; i++)  // заполнение массива 
	{
		parent[i] = i;           // помещаем в массив очередную вершину графа
	}// for i 
	// граф является деревом, если он содержит все вершины графа, такие что нет циклов
	while (number != N - 1)
	{
		int min = INT_MAX;   // для ребра с минимальным весом
		int begin_edge = -1; // вершина начала ребра
		int end_edge = -1;   // вершина конца ребра
		int x = 0;           // перменная для хранения начала ребра
		int y = 0;           // перменная для хранения конца ребра
		// идём по строкам матрицы смежности
		for (int i = 0; i < N; i++)
		{
			// идём по столбцам матрицы смежности
			for (int j = 0; j < N; j++)
			{
				// поиск минимального ребра и проверка на принадлежность одному множеству и существование ребра
				if (findParent(i, parent) != findParent(j, parent) && matrix[i][j] < min && matrix[i][j] != 0) 
				{
					min = matrix[i][j];                  // запоминаем очередное ребро, пока не найдём минимальное
					begin_edge = findParent(i, parent);  // хранит корень множества, где находится вершина i
					end_edge = findParent(j, parent);    // хранит корень множества, где находится вершина j
					x = i; // переменная для хранения i-ой вершины
					y = j; // переменная для хранения j-ой вершины

				}// if
			}// for j
		}// for i
		number = number + 1;           // прибавление кол-ва ребра                      
		parent[begin_edge] = end_edge; // объединение множества, где находится вершина begin_edge и множества где находится вершина end_edge
		cout << "Ребро: " << "(" << x << "," << y << ") " << "вес ребра - " << min << endl;
		weight = weight + min;         // добавляем к весу дерева новое ребро
	}// while(number != N - 1)
	delete[] parent;                   // освобождение выделенной памяти
	cout << "Вес минимального остовного дерева = " << weight << endl;
	return;                            // вернули обещанное значение в caller
}// Kruskala_matr()


/*-------------------------------------------------------------*/
/* алгоритм Крускала через списки смежности  */
/*-------------------------------------------*/
void Kruskala_list(Node** ish_versh   // указатель на массив указателей
	             , int N)             // количество вершин графа
{
	Node* ptr = NULL;            // для движения по спискам смежности массива
	int number = 0;              // переменная для количества пройденных рёбер
	int weight = 0;              // вес минимального остовного дерева
	int* parent = new int[N];    // выделение памяти под массив для поиска родителей

	for (int i = 0; i < N; i++)  // заполнение массива 
	{
		parent[i] = i;           // помещаем в массив очередную вершину графа
	}// for i 
	// граф является деревом, если он содержит все вершины графа, такие что нет циклов
	while (number != N - 1)
	{
		int min = INT_MAX;       // для ребра с минимальным весом
		int begin_edge = -1;     // вершина начала ребра
		int end_edge = -1;       // вершина конца ребра
		int x = 0;               // перменная для хранения начала ребра
		int y = 0;               // перменная для хранения конца ребра
		// идём по строкам массива указателей на списки
		for (int i = 0; i < N; i++)
		{
			ptr = ish_versh[i];  // рассматриваем массив построчно, а граф-по вершинам
			// идём по столбцам матрицы смежности
			while(ptr!=NULL)
			{
				// поиск минимального ребра и проверка на принадлежность одному множеству и существование ребра
				if (findParent(i, parent) != findParent(ptr->versh, parent) && ptr->weight< min)
				{
					min = ptr->weight;                   // запоминаем очередное ребро, пока не найдём минимальное
					begin_edge = findParent(i, parent);  // хранит корень множества, где находится вершина i
					end_edge = findParent(ptr->versh, parent);    // хранит корень множества, где находится вершина j
					x = i;           // переменная для хранения i-ой вершины
					y = ptr->versh; // переменная для хранения j-ой вершины

				}// if
				// двигаемся по списку
				ptr = ptr->next;
			}//while(ptr!=NULL)
		}// for i
		number = number + 1;           // прибавление кол-ва ребра                      
		parent[begin_edge] = end_edge; // объединение множества, где находится вершина begin_edge и множества где находится вершина end_edge
		cout << "Ребро: " << "(" << x << "," << y << ") " << "вес ребра - " << min << endl;
		weight = weight + min;         // добавляем к весу дерева новое ребро
	}// while(number != N - 1)
	delete[] parent;                   // освобождение выделенной памяти
	cout << "Вес минимального остовного дерева = " << weight << endl;
	return;                            // вернули обещанное значение в caller
}// Kruskala_list()